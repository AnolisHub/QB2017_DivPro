diffslope(df$geo.dist, df$unifrac, df$geo.dist, df$bray.curtis)
summary(DD.reg.bc)
summary(DD.reg.uni)
PDAR <- function(comm, tree){
areas <- c()
diversity <- c()
num.plots <- c(2, 4, 8, 16, 32, 51)
for (i in num.plots){
areas.iter <- c()
diversity.iter <- c()
for (j in 1:10){
pond.sample <- sample(51, replace = FALSE, size = i)
area <- 0
sites <- c()
for (k in pond.sample) {
area <- area + pond.areas[k]
sites <- rbind(sites, comm[k, ])
}
areas.iter <- c(areas.iter, area)
psv.vals <- psv(sites, tree, compute.var = FALSE)
psv <- psv.vals$PSVs[1]
diversity.iter <- c(diversity.iter, as.numeric(psv))
}
diversity <- c(diversity, mean(diversity.iter)) # Let Diversity be the Mean PSV
areas <- c(areas, mean(areas.iter)) # Let areas be the Average Area
print(c(i, mean(diversity.iter), mean(areas.iter))) # Print As We Go
}
# Return vectors of areas (x) and diversity (y)
return(cbind(areas, diversity))
}
#1
pond.areas <- as.vector(pi * (env$Diameter/2)^2)
#2
pdar <- PDAR(comm, phy)
pdar <- as.data.frame(pdar)
pdar$areas <- sqrt(pdar$areas)
#3
Pearson <- cor.test(pdar$areas, pdar$diversity, method = "pearson")
P <- round(Pearson$estimate, 2)
P.pval <- round(Pearson$p.value, 3)
Spearman <- cor.test(pdar$areas, pdar$diversity, method = "spearman")
rho <- round(Spearman$estimate, 2)
rho.pval <- round(Spearman$p.value, 3)
#4
plot.new()
par(mfrow=c(1, 1), mar = c(1, 5, 2, 1) + 0.1, oma = c(2, 0, 0, 0))
plot(pdar[, 1], pdar[, 2], xlab = "Area", ylab = "PSV", ylim = c(0, 1),main = "Phylogenetic Diversity-Area Relationship",col = "#a96632", pch = 16, las = 1)
legend("topleft", legend= c(paste("Spearman Correlation = ", rho, "; p = ", rho.pval, sep = ""),paste("Pearson Correlation = ", P, "; p = ", P.pval, sep = "")),bty = "n", col = "#a96632")
Pearson <- cor.test(pdar$areas, pdar$diversity, method = "pearson")
P <- round(Pearson$estimate, 2)
P.pval <- round(Pearson$p.value, 3)
Spearman <- cor.test(pdar$areas, pdar$diversity, method = "spearman")
rho <- round(Spearman$estimate, 2)
rho.pval <- round(Spearman$p.value, 3)
#4
plot.new()
par(mfrow=c(1, 1), mar = c(1, 5, 2, 1) + 0.1, oma = c(2, 0, 0, 0))
plot(pdar[, 1], pdar[, 2], xlab = "Area", ylab = "PSV", ylim = c(0, 1),main = "Phylogenetic Diversity-Area Relationship",col = "#a96632", pch = 16, las = 1)
legend("topleft", legend= c(paste("Spearman Correlation = ", rho, "; p = ", rho.pval, sep = ""),paste("Pearson Correlation = ", P, "; p = ", P.pval, sep = "")),bty = "n", col = "#a96632")
abline(pdar$areas, pdar$diversity)
dufit<-lm(pdar$areas, pdar$diversity)
dufit<-lm(pdar$areas ~ pdar$diversity)
abline(pdar$areas, pdar$diversity)
dufit
plot.new()
par(mfrow=c(1, 1), mar = c(1, 5, 2, 1) + 0.1, oma = c(2, 0, 0, 0))
plot(pdar[, 1], pdar[, 2], xlab = "Area", ylab = "PSV", ylim = c(0, 1),main = "Phylogenetic Diversity-Area Relationship",col = "#a96632", pch = 16, las = 1)
legend("topleft", legend= c(paste("Spearman Correlation = ", rho, "; p = ", rho.pval, sep = ""),paste("Pearson Correlation = ", P, "; p = ", P.pval, sep = "")),bty = "n", col = "#a96632")
dufit<-lm(pdar$diversity~pdar$areas )
dufit
plot.new()
par(mfrow=c(1, 1), mar = c(1, 5, 2, 1) + 0.1, oma = c(2, 0, 0, 0))
plot(pdar[, 1], pdar[, 2], xlab = "Area", ylab = "PSV", ylim = c(0, 1),main = "Phylogenetic Diversity-Area Relationship",col = "#a96632", pch = 16, las = 1)
legend("topleft", legend= c(paste("Spearman Correlation = ", rho, "; p = ", rho.pval, sep = ""),paste("Pearson Correlation = ", P, "; p = ", P.pval, sep = "")),bty = "n", col = "#a96632")
dufit<-lm(pdar$diversity~pdar$areas )
abline(slope=-0.00002398, intercept=.4266, col="#dbd4ab")
abline(-0.00002398,
.4266, col="#dbd4ab")
#4
plot.new()
par(mfrow=c(1, 1), mar = c(1, 5, 2, 1) + 0.1, oma = c(2, 0, 0, 0))
plot(pdar[, 1], pdar[, 2], xlab = "Area", ylab = "PSV", ylim = c(0, 1),main = "Phylogenetic Diversity-Area Relationship",col = "#a96632", pch = 16, las = 1)
legend("topleft", legend= c(paste("Spearman Correlation = ", rho, "; p = ", rho.pval, sep = ""),paste("Pearson Correlation = ", P, "; p = ", P.pval, sep = "")),bty = "n", col = "#a96632")
dufit<-lm(pdar$diversity~pdar$areas )
abline(-0.00002398,
.4266, col="#dbd4ab")
#4
plot.new()
par(mfrow=c(1, 1), mar = c(1, 5, 2, 1) + 0.1, oma = c(2, 0, 0, 0))
plot(pdar[, 1], pdar[, 2], xlab = "Area", ylab = "PSV", ylim = c(0, 1),main = "Phylogenetic Diversity-Area Relationship",col = "#a96632", pch = 16, las = 1)
legend("topleft", legend= c(paste("Spearman Correlation = ", rho, "; p = ", rho.pval, sep = ""),paste("Pearson Correlation = ", P, "; p = ", P.pval, sep = "")),bty = "n", col = "#a96632")
dufit<-lm(pdar$diversity~pdar$areas )
abline(.4266,-0.00002398, col="#dbd4ab")
rm(list=ls())
getwd()
#setwd
#vegan
#install.packages("vegan")
require(vegan)
#install.packages('sp') # Classes and methods for handling spatial data
require(sp)
#install.packages('gstat') # geostatistical analyses
require(gstat)
#install.packages('raster') # create a RasterLayer object
require(raster)
#install.packages('RgoogleMaps') #find Google server for static maps.
require(RgoogleMaps)
#install.packages('maptools') # Tools for geospatial data
require(maptools)
#install.packages('rgdal') # Geospatial Data Abstraction Library
require(rgdal)
#install.packages('simba')
require("simba")
#install.packages('gplots')
require("gplots")
? simba
? rgdal
? sp
#install.packages("ggplot2")
require(ggplot2)
Ponds <- read.table(file = "BrownCoData/20130801_PondDataMod.csv", head = TRUE, sep = ",")
lats <- as.numeric(Ponds[, 3]) # latitudes (north and south)
lons <- as.numeric(Ponds[, 4]) # longitudes (east and west)
OTUs <- read.csv(file = "BrownCoData/SiteBySpecies.csv", head = TRUE, sep = ",")
otu.names = names(OTUs)
OTUs<-as.data.frame(OTUs[-1])
str(OTUs)
S.obs <- function(x=""   ){
rowSums(x>0) *1
}#for each row x, take the sum of columns for whcih x > 0
max(S.obs(OTUs))
newmap <- GetMap(center = c(39.1,-86.3), zoom = 10,destfile = "PondsMap.png", maptype="terrain")
PlotOnStaticMap(newmap, zoom = 10, cex = 2, col = 'blue') # Plot map in RStudio
PlotOnStaticMap(newmap, lats, lons, cex = 1, pch = 20, col = 'red', add = TRUE)
# 1. Import TreeCover.tif as a raster file.
Tree.Cover <- raster("TreeCover/TreeCover.tif")
# 2. Plot the % tree cover data
plot(Tree.Cover, xlab = 'Longitude', ylab = 'Latitude',
main = 'Map of geospatial data for % tree cover,\nwater bodies, and sample sites')
# 3. Import water bodies as a shapefile.
Water.Bodies <- readShapeSpatial("water/water.shp")
# 4. Plot the water bodies around our study area, i.e., Monroe County.
plot(Water.Bodies, border='cyan', axes = TRUE, add = TRUE)
# 5. Convert lat-long data for ponds to georeferenced points.
Refuge.Ponds <- SpatialPoints(cbind(lons, lats))
# 6. Plot the refuge pond locations
plot(Refuge.Ponds, line='r', col='red', pch = 20, cex = 1.5, add = TRUE)
# 1) Calculate Bray-Curtis similarity between plots using the `vegdist()` function
comm.dist <- 1 - vegdist(OTUs)#this is Bray-Curtis similarity
# 2) Assign UTM lattitude and longitude data to 'lats' and 'lons' variables
xy <- data.frame(pond.name = Ponds$Sample_ID, lats = Ponds$lat, lons = Ponds$long)
coordinates(xy) <- ~lats+lons#lat-lon dataframe
# Identify the current projection
proj4string(xy) <- CRS("+proj=longlat +datum=NAD83")
# Transform the projection and data to UTM
UTM <- spTransform(xy, CRS("+proj=utm +zone=51 +ellps=WGS84"))
UTM <- as.data.frame(UTM)
Ponds$lats_utmm <- UTM[,2] # latitude data
Ponds$lons_utmm <- UTM[,3] # longitude data
coordinates(Ponds) = ~lats_utmm+lons_utmm
vgm <- variogram(TDS~1, data=Ponds)
vgm.fit = fit.variogram(vgm, model = vgm(1, "Sph", 900, 1,fit.sill=F, fit.range=F))
plot(vgm, vgm.fit)
lats <- as.numeric(Ponds$lats_utmm) # lattitude data
lons <- as.numeric(Ponds$lons_utmm) # longitude data
# 3) Calculate geographic distance between plots and assign to the variable 'coord.dist'
coord.dist <- dist(as.matrix(lats, lons))#for each lat & its corresponding lon, calculate the orthodromic distance between them
# 4) Transform environmental data to numeric type, and assign to variable 'x1'
x1 <- as.numeric(Ponds$"SpC")
# 5) Using the `vegdist()` function in `simba`, calculate the Euclidean distance between the plots for environmental variables. Assign the result to the variable 'env.dist'
env.dist <- vegdist(x1, "euclidean")
# 6) Transform all distance matrices into database format using the `liste()` function in `simba`:
comm.dist.ls <- liste(comm.dist, entry="comm")#must learn more abt "entry"
env.dist.ls <- liste(env.dist, entry="env")
coord.dist.ls <- liste(coord.dist, entry="dist")
# 7) Create a data frame containing similarity of the environment and similarity of community.
df <- data.frame(coord.dist.ls, env.dist.ls[,3], comm.dist.ls[,3])
# 8) Attach the columns labels 'env' and 'struc' to the dataframe you just made.
names(df)[4:5] <- c("env", "struc")
attach(df)
# 9) After setting the plot parameters, plot the distance-decay relationships, with regression lines in red.
par(mfrow=c(1, 2), pty="s")
plot(env, struc, xlab="Environmental Distance", ylab="1 - Bray-Curtis",
main = "Environment", col='SteelBlue')
OLS <- lm(struc ~ env)
OLS # print regression results to the screen
abline(OLS, col="red4")
plot(dist, struc, xlab="Geographic Distance", ylab="1 - Bray-Curtis",
main="Community\nComposition", col='darkorchid4')
OLS <- lm(struc ~ dist)
OLS # print regression results to the screen
abline(OLS, col="red4")
# 10) Use `simba` to calculate the difference in slope or intercept of two regression lines
diffslope(env, struc, dist, struc)
# 1. Define an SSAD function
ssad <- function(x){
ad <- c(2, 3)
ad <- OTUs[, otu]
ad = as.vector(t(x = ad))
ad = ad[ad > 0]
}
# 2. Set plot parameters
par(mfrow=c(2, 3))
# 3. Declare a counter variable
ct <- 0
# 4. Write a while loop to plot the SSADs of six species chosen at random
while (ct < 6){
otu <- sample(1:length(OTUs), 1) # random column
ad <- ssad(otu) # find the OTU's SSAD
if (length(ad) > 10 & sum(ad > 100)){ #if present in >10 sites with abundance >100, use this OTU
ct <- ct + 1#and increment the counter
plot(density(ad), col = 'red', xlab='Site abundance',
ylab='Probability Density', main = otu.names[otu])
}
}
# 1. Declare variables to hold simulated community and species information
community <- c() #empty community
species <- c() # empty species vector
# 2. Populate the simulated landscape
# initiate the plot
plot(0, 0, col='white', xlim = c(0, 100), ylim = c(0, 100), xlab='x coordinate', ylab='y coordinate', main='A simulated landscape occupied by 100 species, having 1 to 1000 individuals each.')
while (length(community) < 100){# choose the mean, standard deviation, and species color at random
std <- runif(1, 1, 10) # random sample from a uniform distribution
ab <- sample(1000, 1) # random number
x <- rnorm(ab, mean = runif(1, 0, 100), sd = std) # 1000 random numbers from a Normal distribution for x values, centered at a random value (ab) (I think)
y <- rnorm(ab, mean = runif(1, 0, 100), sd = std) # 1000 random numbers from a Normal distribution for y values, centered at a random value (ab)
color <- c(rgb(runif(1),runif(1),runif(1))) # Let each species have a randomly chosen color
points(x, y, pch=".", col=color) # Add points to a plot
species <- list(x, y, color) # The species color, x-coords, and y-coords
community[[length(community)+1]] <- species # Add the species' info to the community
}
# 1. Declare the spatial extent and lists to hold species richness and area data
lim <- 10 # grain
S.list <- c() #spp vector
A.list <- c() #spatial scale vector
# 2. Construct a 'while' loop and 'for' loop combination to quantify the numbers of species for progressively larger areas of the simulated landscape.
while (lim <= 100){ # while the spatial extent <= 100...
S <- 0 # initiate richness
for (sp in community){ # for each species in the community
xs <- sp[[1]] # assign the x coords
ys <- sp[[2]] # assign the y coords
sp.name <- sp[[3]] # assign the species name
xy.coords <- cbind(xs, ys) # combine the columns for x and y coordinates
for (xy in xy.coords){ # for each pair of xy coordinates
if (max(xy) <= lim){ # if the individual is within our current spatial extent...
S <- S + 1 # then the species occurs there
break # break out of the last for loop because we now know the species occurs inside this sampling
}
}
}
S.list <- c(S.list, log10(S))
A.list <- c(A.list, log10(lim^2))
lim <- lim * 2 # increase the extent multiplicatively
}
# 3. Be sure to log10-transform the richness and area data
#I did this within the while loop
results <- lm(S.list ~ A.list)
plot(A.list, S.list, col="#e003f4", pch=20, cex=2, main="Species-area relationship", xlab='ln(Area)', ylab='ln(Richness)')
abline(results, col="#2da55d", lwd=2)
int <- round(results[[1]][[1]],2)
z <- round(results[[1]][[2]],5)
legend(x=2, y=2, paste(c('slope = ', z), collapse = " "), cex=0.8,
box.lty=0)
plant<-read.csv("C:\\Users\\rmoge\\GitHub\\QB2017_DivPro\\Data\\HF_plants.csv",header=TRUE,sep=",")
#print(dim(plant))
#print(names(plant))
#install.packages("dplyr")
require(dplyr)
plants.sortedT<-arrange(plant, treatment)
plants.sortedY<-arrange(plants.sortedT,year)
plants.sortedP<-arrange(plants.sortedY,plot)
my2009plants.sortedY<-filter(plants.sortedY, year==2009)
dim(my2009plants.sortedY)
sbs2009plants.sortedYt<-my2009plants.sortedY[4:43]
sbs2009plants.sortedYtt<-as.data.frame(sbs2009plants.sortedYt[-16,])
soilenv<-read.csv("C:\\Users\\rmoge\\GitHub\\QB2017_DivPro\\Data\\HF_soilresp.csv")
my2009soilenv<-filter(soilenv,year==2009,day==14,month==1)
temporary_soil<-my2009soilenv[-9]
sbs2009soilenv<-as.matrix(temporary_soil[8:11])
mycolnames<-colnames(sbs2009plants.sortedYtt, do.NULL = TRUE, prefix = "col")
# 2. Set plot parameters
par(mfrow=c(2, 2))
# 3. Declare a counter variable
ct <- 0
# 4. Write a while loop to plot the SSADs of 4 species chosen at random
while (ct < 4){
tree.sp <- sample(1:length(sbs2009plants.sortedYtt), 1) # random column
ad <- ssad(tree.sp) # find the OTU's SSAD
#k <- arrayInd(tree.sp, dim(mdat))
if (length(ad) > 2 & sum(ad > 2)){ #if present in >10 sites with abundance >100, use this species
ct <- ct + 1#and increment the counter
plot(density(ad), col = 'red', xlab='Site abundance',
ylab='Probability Density', main = names(sbs2009plants.sortedYtt)[tree.sp])
}
}
setwd("C:\\Users\\rmoge\\GitHub\\QB2017_DivPro\\Data")
clr = function() {
ENV = globalenv()
ll = ls(envir = ENV)
ll = ll[ll != "clr"]
rm(list = ll, envir = ENV)
}
getwd()
setwd("/Users/bhbeidler/GitHub/QB2017_DivPro/Data")
package.list = c('vegan', 'tidyr', 'dplyr', 'codyn', 'ggplot2','betapart','splitstackshape','cowplot', 'MullerPlot', 'RColorBrewer','lubridate', 'reshape2', 'lubridate','wesanderson','TTR', 'xtable', 'multcomp', 'pander', 'png', 'grid', 'tseries', 'nlme', 'forecast', 'lsmeans', 'devtools')
for (package in package.list) {
if (!require(package, character.only = TRUE, quietly = TRUE)) {
install.packages(package, repos='http://cran.us.r-project.org')
library(package, character.only = TRUE) }
}
setwd("/Users/bhbeidler/GitHub/QB2017_DivPro/Data")
plant = read.csv("./HF_plants_treat.csv")
plant = read.csv("HF_plants_treat.csv")
plant = read.csv("\\HF_plants_treat.csv")
plant = read.csv("C:\\Users\\rmoge\\GitHub\\QB2017_DivPro\\Data\\HF_plants_treat.csv")
nmin = read.csv("C:\\Users\\rmoge\\GitHub\\QB2017_DivPro\\DataHF_nmin.csv", stringsAsFactors = FALSE)
nmin = read.csv("C:\\Users\\rmoge\\GitHub\\QB2017_DivPro\\Data\\HF_nmin.csv", stringsAsFactors = FALSE)
resp = read.csv("C:\\Users\\rmoge\\GitHub\\QB2017_DivPro\\Data\\HF_soilresp.csv", stringsAsFactors = FALSE)
# Making the Site by Species Matrix for the plant data set
plant_sbys = plant[ ,6:43]
# Subsetting the data into the different years
plant_06 = (filter(plant, year == 2006))
plant_07 = (filter(plant, year == 2007))
plant_08 = (filter(plant, year == 2008))
plant_09 = (filter(plant, year == 2009))
# Separating out the treatments from the site by species matrices
plant_06_sbys = plant_06[ ,6:43]
plant_07_sbys = plant_07[ ,6:43]
plant_08_sbys = plant_08[ ,6:43]
plant_09_sbys = plant_09[ ,6:43]
# Visualizing the Plant data set
str(plant, max.level = 1)
# Calculate observed richness from time-by-species matrix
p_richness = as.data.frame(rowSums(plant[,-c(1:5)] > 0))
# Create data frame with experimental design and richness data
p_rich.all = data.frame(plant[,1:5,], p_richness)
# Rename column
names(p_rich.all)[6] = "richness"
# avg. richness per group
# stand. dev. per group
# num. obs. per group
# calc. std. err. mean.
p_rich.treat.plot = group_by(p_rich.all, treatment, year) %>%
summarise(mean = mean(richness), sd = sd(richness),n = n(),sem = sd/sqrt(n))
p_rich.plot = ggplot(p_rich.treat.plot, aes(x = year, y = mean, color = as.factor(treatment))) +
geom_point(size = 2, show.legend = T) +
geom_line(size = 0.75) +
geom_errorbar(aes(ymin = mean - sem, ymax = mean + sem), width = .1) +
scale_color_manual(values = c("#999999", "#E69F00", "#000000", "#56B4E9"),name="Soil Treatment",labels=c("Unheated-Unfertilized", "Heated-Unfertilized", "Heated- Fertilized", "Unheated-Fertilized")) +
xlim(2006, 2009) + xlab("Year") + ylab("Richness") +
theme_classic(base_size=15)+
theme(axis.line.x = element_line(color = "black"), axis.line.y = element_line(color ="black"))
plot(p_rich.plot)
# Calculate diveristy from time-by-species matrix
p_diversity = diversity(plant[,-c(1:5)], "shannon")
# Create data frame with experimental design and diversity data
p_div.all = data.frame(plant[,1:5,], p_diversity)
# Rename column
names(p_div.all)[6] = "diversity"
p_div.treat.plot = group_by(p_div.all, treatment, year) %>%
summarise(mean = mean(diversity), sd = sd(diversity),n = n(),sem = sd/sqrt(n))
p_div.plot = ggplot(p_div.treat.plot, aes(x = year, y = mean, color = as.factor(treatment))) +
geom_point(size = 2, show.legend = T) +
geom_line(size = 0.75) +
geom_errorbar(aes(ymin = mean - sem, ymax = mean + sem), width = .1) +
scale_color_manual(values = c("#999999", "#E69F00", "#000000", "#56B4E9"),name="Soil Treatment",labels=c("Unheated-Unfertilized", "Heated-Unfertilized", "Heated- Fertilized", "Unheated-Fertilized")) +
xlim(2006, 2009) + xlab("Year") + ylab("Shannon's Diversity Index")+
theme_classic(base_size=15)+
theme(axis.line.x = element_line(color = "black"),axis.line.y = element_line(color = "black"))
plot(p_div.plot)
p_rich.rm = lme(richness ~ year + heat_treat + N_treat * heat_treat * N_treat * year, random = ~ 1 | plot, correlation = corAR1(form = ~ 1 | plot),data = p_rich.all)
summary(p_rich.rm) # Obtain F-test
anova(p_rich.rm)
# Make cleaner ANOVA table
set.caption("RMANOVA for Plant Richness Data")
pander(anova(p_rich.rm))
# Perform an RM-ANOVA and construct a F-test using the AR(1)
p_div.rm = lme(diversity ~ year + heat_treat + N_treat * heat_treat * N_treat * year, random = ~ 1 | plot, correlation = corAR1(form = ~ 1 | plot),data = p_div.all) # Look at detailed output
summary(p_div.rm) # Obtain F-test
anova(p_div.rm)
set.caption("RMANOVA for Plant Diversity Data")
pander(anova(p_div.rm))
# Making the wide site by species format into a long format- to get abundances for each species
plant$row_id = 1:nrow(plant)
p.id = dplyr::select(plant, row_id, year, treatment)
plant.m = as.matrix(plant_sbys)
m1 = setNames(melt(plant.m), c('row_id','species','count'))
m2 = dplyr::filter(m1, count > 0)
m3 = expandRows(m2, "count")
plant_long = left_join(p.id,m3, by = "row_id")
p_long = dplyr::select(plant_long, -row_id)
# Calculate species abundances for each taxonomic group
plant.sp.abunds = p_long %>%
group_by(year,treatment) %>%
count(species)
# Calculate total turnover
plant.total = turnover(df = plant.sp.abunds, time.var = "year",
species.var = "species",
abundance.var = "n",
replicate.var = "treatment",
metric = "total")
# Calculate species gained
plant.appearance = turnover(df = plant.sp.abunds, time.var = "year",
species.var = "species",
abundance.var = "n",
replicate.var = "treatment",
metric = "appearance")
# Calculate species lost
plant.disappearance = turnover(df = plant.sp.abunds, time.var = "year",
species.var = "species",
abundance.var = "n",
replicate.var = "treatment",
metric = "disappearance")
plant.turnover = full_join(plant.total, plant.disappearance) %>%
full_join(plant.appearance)
plant.turnover = gather(plant.turnover, key = metric, value = turnover, total, appearance, disappearance)
View(plant.turnover)
# 3. Visualize turnover within each group
plant.turn.plot = ggplot(plant.turnover, aes(x = year, y = turnover, color = metric)) +
geom_line(size = 1, show.legend = T) + facet_wrap(~treatment, ncol = 1) +
xlim(2007, 2009) +
xlab("Year") +
ylab("Turnover") +
theme(legend.position = "bottom") +
scale_color_grey()
plot(plant.turn.plot)
# Low turnover is indicative of a stable community and high turnover is indicative of a dynamic community
# Abundance Plots
p_abun.plot = ggplot(plant.sp.abunds, aes(year, n, color= as.factor(treatment))) +
geom_point() +
geom_line(aes(color = as.factor(treatment))) +
facet_wrap(~species, nrow = 8) +
scale_color_manual(values = c("#999999", "#E69F00", "#000000", "#56B4E9"),name="Soil Treatment",labels=c("Unheated-Unfertilized", "Heated-Unfertilized", "Heated- Fertilized", "Unheated-Fertilized")) +
ylab("# of  Stems") +
theme_bw() +
theme(axis.text.x = element_text(angle=70, vjust=0.5))
# Abundances at time point 1
p_abun.06 = dplyr::filter(plant.sp.abunds, year == "2006")
p_abun.plot.06 = ggplot(p_abun.06 , aes(x = species, y = n)) +
geom_bar(stat = "identity") +
facet_wrap(~treatment, ncol = 1) +
ylab("# of  Stems") +
theme_bw() +
theme(axis.text.x = element_text(angle=70, vjust=0.5))
# Abundances at time point 2
p_abun.09 = dplyr::filter(plant.sp.abunds, year == "2009")
p_abun.plot.09 = ggplot(p_abun.09 , aes(x = species, y = n)) +
geom_bar(stat = "identity") +
facet_wrap(~treatment, ncol = 1) +
ylab("# of  Stems") +
theme_bw() +
theme(axis.text.x = element_text(angle=70, vjust=0.5))
# Calculate species abundances for each taxonomic group
plant.sp.abunds = p_long %>%
group_by(year,treatment) %>%
count(species)
# Calculate MRS
plant.rankshift = rank_shift(df = as.data.frame(plant.sp.abunds),
time.var = "year",
species.var = "species",
abundance.var = "n",
replicate.var = "treatment")
plant.rankshift$year = as.numeric(substr(plant.rankshift$year_pair, 6, 9))
# Create ggplot
rankshift.plot =  ggplot(plant.rankshift, aes(x = year, y = MRS, color = treatment)) + geom_line(size = 1) +
xlim(2007, 2009) +
xlab("Year") +
ylab("Mean Rank Shift") + scale_color_grey()
plot(rankshift.plot)
portal.rankshift %>%
group_by (plot_type) %>%
summarise(mean = mean(MRS), cv = sd(MRS)/mean)
# Soil respiration
resp = resp %>%
filter(year %in% c( "2006","2007", "2008", "2009"))
resp$date = as.Date(resp$date, format = "%m/%d/%Y")
resp$doy = yday(resp$date)
resp = na.exclude(resp)
resp_yr.plot = qplot(doy, co2flux, data = resp, geom="smooth") +
stat_smooth(fill="azure3", colour="mediumpurple4", size=1, alpha = 0.2) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line =   element_line(colour = "black")) +
facet_wrap(~year, ncol = 1)
xlab("Day of the Year") +
ylab("CO2 Flux")
resp_yr.plot = qplot(doy, co2flux, data = resp, geom="smooth") +
stat_smooth(fill="azure3", colour="mediumpurple4", size=1, alpha = 0.2) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line =   element_line(colour = "black")) +
facet_wrap(~year, ncol = 1)
xlab("Day of the Year") +
ylab("CO2 Flux")
resp_trt.plot = qplot(doy, co2flux, data = resp, colour = as.factor(trt), geom="smooth", se=FALSE) +
stat_smooth(method ="auto",se = FALSE, formula = y ~ x, size = 1) +
facet_wrap(~year, ncol = 1) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"))
resp_trt.plot + scale_colour_brewer(type="seq", palette=3) + xlab("Day of the Year") +ylab("CO2 Flux)") + theme(text = element_text(size=18))
plot(resp_trt.plot)
# N mineralization
nmin = nmin %>%
filter(year %in% c("2006","2007", "2008", "2009"))
nmin$date = as.Date(nmin$date, format = "%m/%d/%Y")
nmin$doy = yday(nmin$date)
nmin = na.remove(nmin)
n03_yr.plot = qplot(doy, netno3, data = nmin, geom="smooth") +
stat_smooth(fill="azure3", colour="mediumpurple4", size=1, alpha = 0.2) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line =   element_line(colour = "black")) +
facet_wrap(hor~year)
xlab("Day of the Year") +
ylab("Net Nitrate")
